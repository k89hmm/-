<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>좌형의 안민철 피하기</title>
<style>
html, body {margin:0; padding:0; overflow:hidden; background:#111;}
canvas {display:block;}
#controls {
  position:absolute; top:10px; left:50%; transform:translateX(-50%);
  display:flex; gap:8px; align-items:center; z-index:10;
}
button {padding:8px 12px; border-radius:6px; border:none; background:#2b6df6; color:white; cursor:pointer;}
#score { font-weight:700; color:#fff; }
h1 {position:absolute; top:10px; left:50%; transform:translateX(-50%); color:#fff; z-index:10; margin:0;}
</style>
<script src="https://cdn.jsdelivr.net/npm/brython@3.12.1/brython.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/brython@3.12.1/brython_stdlib.js"></script>
</head>
<body onload="brython()">
<h1>좌형의 안민철 피하기</h1>
<div id="controls">
  <button id="start">시작</button>
  <div id="score">점수: 0</div>
</div>
<canvas id="game"></canvas>

<script type="text/python3">
from browser import document, html, timer, window
import math, random

CANVAS = document['game']
ctx = CANVAS.getContext('2d')

# ------------------ Stage & Scaling ------------------
STAGE_W, STAGE_H = 480, 640
W, H = window.innerWidth, window.innerHeight
scale, offset_x, offset_y = 1,0,0

def update_scale(ev=None):
    global W,H,scale,offset_x,offset_y
    W = window.innerWidth
    H = window.innerHeight
    CANVAS.width = W
    CANVAS.height = H
    scale_x = W / STAGE_W
    scale_y = H / STAGE_H
    global scale, offset_x, offset_y
    scale = min(scale_x, scale_y)
    offset_x = (W - STAGE_W*scale)/2
    offset_y = (H - STAGE_H*scale)/2

update_scale()
window.bind('resize', update_scale)

# ------------------ Game Variables ------------------
player = {'x': STAGE_W/2, 'y': STAGE_H/2, 'w':50, 'h':50, 'speed':6}
bullets = []
spawn_interval = 700
last_spawn = 0
running = False
score = 0
keys = {'left':False,'right':False,'up':False,'down':False}
difficulty_timer = 0
player_loaded = False
touch_active = False
touch_x = 0
touch_y = 0

# ------------------ Images ------------------
player_img = html.IMG()
player_img.src = 'player.png'
bullet_img = html.IMG()
bullet_img.src = 'bullet.png'
bg_img = html.IMG()
bg_img.src = 'background.png'

player_img.bind('load', lambda ev: globals().update({'player_loaded': True}))
bg_loaded = False
def bg_load(ev):
    global bg_loaded
    bg_loaded = True
bg_img.bind('load', bg_load)

# ------------------ Bullet Spawn ------------------
def spawn_bullet():
    side = random.choice(['top','bottom','left','right'])
    size = random.uniform(6,14)
    speed = random.uniform(2.0,4.2)+(score/200.0)
    if side=='top':
        x=random.uniform(0,STAGE_W); y=-size; vx=random.uniform(-1,1); vy=speed
    elif side=='bottom':
        x=random.uniform(0,STAGE_W); y=STAGE_H+size; vx=random.uniform(-1,1); vy=-speed
    elif side=='left':
        x=-size; y=random.uniform(0,STAGE_H); vx=speed; vy=random.uniform(-1,1)
    else:
        x=STAGE_W+size; y=random.uniform(0,STAGE_H); vx=-speed; vy=random.uniform(-1,1)
    bullets.append({'x':x,'y':y,'vx':vx,'vy':vy,'r':size})

# ------------------ Update ------------------
def update(dt):
    global last_spawn, score, running, difficulty_timer
    if not running: return

    last_spawn += dt
    difficulty_timer += dt
    if last_spawn>=spawn_interval:
        last_spawn=0
        spawn_bullet()

    if difficulty_timer>=5000:
        difficulty_timer=0
        for b in bullets:
            b['vx']*=1.5
            b['vy']*=1.5

    if keys['left']: player['x']-=player['speed']
    if keys['right']: player['x']+=player['speed']
    if keys['up']: player['y']-=player['speed']
    if keys['down']: player['y']+=player['speed']

    if touch_active:
        player['x']+=(touch_x/scale - player['x'])*0.2
        player['y']+=(touch_y/scale - player['y'])*0.2

    player['x']=max(player['w']/2,min(STAGE_W-player['w']/2,player['x']))
    player['y']=max(player['h']/2,min(STAGE_H-player['h']/2,player['y']))

    for b in list(bullets):
        b['x']+=b['vx']
        b['y']+=b['vy']
        if b['x']<-50 or b['x']>STAGE_W+50 or b['y']<-50 or b['y']>STAGE_H+50:
            bullets.remove(b)
            score+=1

    for b in bullets:
        rx=player['x']-player['w']/2
        ry=player['y']-player['h']/2
        closest_x=max(rx,min(b['x'],rx+player['w']))
        closest_y=max(ry,min(b['y'],ry+player['h']))
        dx=(b['x']-closest_x)*0.2
        dy=(b['y']-closest_y)*0.5
        if dx*dx+dy*dy<=b['r']*b['r']:
            running=False
            show_game_over()
            break

# ------------------ Draw ------------------
def draw_background():
    if not bg_loaded: return
    ctx.drawImage(bg_img,0,0,STAGE_W,STAGE_H)

def draw():
    ctx.clearRect(0,0,W,H)
    ctx.save()
    ctx.translate(offset_x,offset_y)
    ctx.scale(scale,scale)
    draw_background()

    if player_loaded:
        ratio = player_img.naturalWidth/player_img.naturalHeight
        draw_w = player['w']*2
        draw_h = draw_w/ratio
        ctx.drawImage(player_img,player['x']-draw_w/2,player['y']-draw_h/2,draw_w,draw_h)
    for b in bullets:
        if bullet_img.complete:
            ratio=bullet_img.naturalWidth/bullet_img.naturalHeight
            draw_w=b['r']*6
            draw_h=draw_w/ratio
            ctx.drawImage(bullet_img,b['x']-draw_w/2,b['y']-draw_h/2,draw_w,draw_h)
        else:
            ctx.beginPath()
            ctx.arc(b['x'],b['y'],b['r']*3,0,2*math.pi)
            ctx.fillStyle='#ff6b6b'
            ctx.fill()
    ctx.restore()
    document['score'].text=f"점수: {score}"

def game_loop():
    update(16)
    draw()

# ------------------ Input ------------------
def on_keydown(ev):
    if ev.key in ('ArrowLeft','a'): keys['left']=True
    if ev.key in ('ArrowRight','d'): keys['right']=True
    if ev.key in ('ArrowUp','w'): keys['up']=True
    if ev.key in ('ArrowDown','s'): keys['down']=True
    if ev.key in ('ArrowLeft','ArrowRight','ArrowUp','ArrowDown'):
        ev.preventDefault()
def on_keyup(ev):
    if ev.key in ('ArrowLeft','a'): keys['left']=False
    if ev.key in ('ArrowRight','d'): keys['right']=False
    if ev.key in ('ArrowUp','w'): keys['up']=False
    if ev.key in ('ArrowDown','s'): keys['down']=False
    if ev.key in ('ArrowLeft','ArrowRight','ArrowUp','ArrowDown'):
        ev.preventDefault()
def on_touch_start(ev):
    global touch_active,touch_x,touch_y
    touch_active=True
    touch_x=ev.touches[0].clientX
    touch_y=ev.touches[0].clientY
    ev.preventDefault()
def on_touch_move(ev):
    global touch_x,touch_y
    if touch_active:
        touch_x=ev.touches[0].clientX
        touch_y=ev.touches[0].clientY
    ev.preventDefault()
def on_touch_end(ev):
    global touch_active
    touch_active=False
    ev.preventDefault()

document.bind('keydown',on_keydown)
document.bind('keyup',on_keyup)
document['game'].bind('touchstart',on_touch_start)
document['game'].bind('touchmove',on_touch_move)
document['game'].bind('touchend',on_touch_end)

# ------------------ Game Control ------------------
def start_game(ev=None):
    global running,bullets,score,last_spawn,difficulty_timer,player
    bullets=[]
    score=0
    last_spawn=0
    difficulty_timer=0
    running=True
    player['x']=STAGE_W/2
    player['y']=STAGE_H/2

def show_game_over():
    ctx.save()
    ctx.translate(offset_x,offset_y)
    ctx.scale(scale,scale)
    ctx.fillStyle='rgba(0,0,0,0.7)'
    ctx.fillRect(0,0,STAGE_W,STAGE_H)
    ctx.fillStyle='#fff'
    ctx.font='48px sans-serif'
    ctx.textAlign='center'
    ctx.fillText('게임 오버',STAGE_W/2,STAGE_H/2-30)
    ctx.font='24px sans-serif'
    ctx.fillText(f'최종 점수: {score}',STAGE_W/2,STAGE_H/2+10)
    ctx.restore()

document['start'].bind('click',start_game)

# ------------------ Start Loop ------------------
def all_images_loaded():
    return player_img.complete and bullet_img.complete and bg_img.complete

def start_loop_when_ready(ts):
    if all_images_loaded():
        timer.request_animation_frame(loop)
    else:
        timer.set_timeout(lambda: start_loop_when_ready(ts),50)

def loop(ts):
    game_loop()
    timer.request_animation_frame(loop)

start_loop_when_ready(0)
</script>
</body>
</html>
